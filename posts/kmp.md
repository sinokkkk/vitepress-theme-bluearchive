---
title: KMP

date: 2025-5-10

tags: [数据结构]

cover: /post_assets/kmp/1.png
---

# next 数组的求法

在 KMP 算法中,为了

根据定义,在我们这`next[j]`指模式串 pattern[0...j]的最大相同**真前缀**和**真后缀**的长度.

要时刻注意一点:"前缀和后缀是相同的"

举个例子在进行到 **next[j]** 时, 已知 next[j-1]的值是 2, 说明[0...j-1]这个子串的相同前缀和后缀长度为 2,那么要求解 next[j],只需要比较左边绿色部分的后一个字符(橙色标出).

而橙色字符的位置,就可以通过现有的前缀长度,就是我们的 next[j-1], 得到橙色字符的位置为 next[ next[j-1] ]

如果相同,那么绿色部分向后增加一个,前缀长度+1. `++prefix_len; next[i]=prefix_len;`

![图标1](/post_assets/kmp/1.png)

那么,如果长度不同呢, 比如 j 之后的这个 B, 显然*ABBB*无法与*ABBC*形成相同前后缀.

![图标1](/post_assets/kmp/2.png)

如该例,既然无法与 ABA 形成相同前后缀,那不如看看存不存在更短的相同前后缀,如这里的 AB

规律就是与 B 结合是从后往前慢慢叠加,找相同的前缀是从开头往右 (比如 AB 是合法的 试图将这个短相同前后缀延长的时候就是尾部的 BAB 和开头的 ABA 比较)

暴力的思路是将 next[j-1]的绿色部分遍历一遍,看是否存在.

KMP 的思路是利用 next 数组已有的信息,直接找到"可以形成更短的相同前后缀的最优位置".

**_观点:"前缀和后缀是相同的"_** ,子串前后的这两个绿色部分,是完全相同的

也就是说右边这部分的后缀等同于左边这部分的后缀,那么直接在左边这部分寻找共同的前后缀就行了.

相当于把 B 接在左绿色部分的后面了,ABA 的共同前后缀长度查表可得是 1,那就跳转到 next[1]与 B 比较,如果相同,长度+1.

如果不同,那就宣布 next[j]=0.

```cpp
while(i<pattern.length()){
    if(pattern[prefix_len-1+1]==pattern[i]){
        ++prefix_len;
        next[i]=prefix_len;
        ++i;
    }else{
        if(prefix_len==0){
            next[i]=0;
            ++i;
        }else{
            prefix_len=next[prefix_len-1];
        }
    }
}
```

**next\[j\]**
